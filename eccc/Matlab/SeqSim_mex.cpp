//	----------------------------------------------------------------------------------------
//	  Copyright (C) Skope AG 2018  All Rights Reserved.
//	----------------------------------------------------------------------------------------
//
//	  Project:	DSP READER
//	     File:	DSP_ECC_mex.cpp
//	  Version:	1.0
//	   Author:	cmirkes
//	     Date:	25.08.2017
//	     Lang:	C++
//
//	  Descrip:	Matlab MEX routine to read DSP xml files generated by Siemens
//				scanners. Supported Siemens software versions: VB17.
//              See SeqSim.cpp for further information.
//
// Compilation: 
//              WINDOWS: 
///                     mex SeqSim_mex.cpp ../SeqSim.cpp ../pugixml.cpp -IC:/MRILibraries/fftw3 -LC:/MRILibraries/fftw3 -llibfftw3-3.lib
//                      
//              LINUX:
//                      mex SeqSim_mex.cpp ../SeqSim.cpp ../pugixml.cpp -lfftw3
//                      
//
//     Scanner:	MriSeqSimRunSeq -p prot.pro DSP.xml
//				MriSeqSimRunSeq -p prot.pro -c PAC_1 DSP.xml  (to use custom coil environment'%MEASDAT%/MeasCoil_PAC_1.dat')
//
//	----------------------------------------------------------------------------------------

/*
%% Example for running the script in MATLAB

CoeffsX.Amp = [0.1134   -0.0790    0.1607];
CoeffsX.Tau = [0.3603    0.0057    0.0020];

CoeffsY.Amp = [0.0076   -0.0891    0.0083];
CoeffsY.Tau = [1.9998    0.1491    0.0020];

CoeffsZ.Amp = [0.2548    0.1812   -0.0143];
CoeffsZ.Tau = [0.5425    0.1226    0.0017];

doInterpToRX = true; 
[RXSamp, RXTime, TXTime, TrigTime, kxADC, kyADC, kzADC] = SeqSim_mex('DSP.xml','kspace',doInterpToRX);

*/

#include "mex.h" 
#include <stdio.h>
#include <string>       

using namespace std;

#include "../SeqSim.h"  

void setB0CorrCoeff(const mxArray *Coeff, SEQSIM::ECC_Coeff &m_Coeff);

//*******************************************************************//
// mexFunction is the gateway routine for the MEX-file               //
//*******************************************************************// 
void mexFunction( int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[] )
{

	//---------------------------------------------------------------------
	// Input/output check
	//---------------------------------------------------------------------
	if (nrhs != 3 && nrhs != 6) {
		mexErrMsgTxt("The path to the xml file and the output mode must always be provided. The ECC coefficients can be omitted depending on the chosen output mode.\n");
	}

	if (mxGetClassID(prhs[0]) != mxCHAR_CLASS ) {
		mexErrMsgTxt("First argument must be file name.\n");
	}
    
    if (mxGetClassID(prhs[1]) != mxCHAR_CLASS ) {
		mexErrMsgTxt("The second argument must a string defining the data type to be returned by the function. Supported output modes are: 'gradient', 'kspace', 'slewRate', 'eddyCurrent' and 'eddyPhase'\n");
	}
    
    if (mxGetClassID(prhs[2]) != mxLOGICAL_CLASS ) {
		mexErrMsgTxt("The third argument must a boolean defining the interpolation mode.\n");
	}
	  	
	//---------------------------------------------------------------------
	// Get file name
	//---------------------------------------------------------------------
	char *pFileName = mxArrayToString(prhs[0]);
       
    //---------------------------------------------------------------------
	// Create DSP object
	//---------------------------------------------------------------------
	SEQSIM::DSP dsp;
    
    //---------------------------------------------------------------------
	// Get file name
	//---------------------------------------------------------------------
    dsp.setFileName( pFileName );
    
    //---------------------------------------------------------------------
	// Get file name
	//---------------------------------------------------------------------
    double *pr  = mxGetPr(prhs[2]); 
    if (pr[0]){
        dsp.setOutputMode( SEQSIM::OutputMode::INTERPOLATED_TO_RX);
    }
    else{
        dsp.setOutputMode( SEQSIM::OutputMode::FULL);
    }
    
    //---------------------------------------------------------------------
	// Get data type to be returned
	//---------------------------------------------------------------------
	char *pDataType = mxArrayToString(prhs[1]);
	string sDataType(pDataType);
    
    if (sDataType.compare("gradient") == 0){
        if (nlhs != 7) { mexErrMsgTxt("Expected output arguments: [RXSamples, RXTime, TXTime, TrigTime, GX, GY, GZ].\n"); }
        dsp.setDataType(SEQSIM::DataType::GRADIENT);
    }
    else if (sDataType.compare("kspace") == 0){
        if (nlhs != 7) { mexErrMsgTxt("Expected output arguments: [RXSamples, RXTime, TXTime, TrigTime, KX, KY, KZ].\n"); }
        dsp.setDataType(SEQSIM::DataType::KSPACE);
    }
    else if (sDataType.compare("slewRate") == 0){
        if (nlhs != 7) { mexErrMsgTxt("Expected output arguments: [RXSamples, RXTime, TXTime, TrigTime, SX, SY, SZ].\n"); }
        dsp.setDataType(SEQSIM::DataType::SLEWRATE);
    }
    else if (sDataType.compare("eddyCurrent") == 0){
        if (nlhs != 7) { mexErrMsgTxt("Expected output arguments: [RXSamples, RXTime, TXTime, TrigTime, ECCX, ECCY, ECCZ].\n"); }
        dsp.setDataType(SEQSIM::DataType::EDDYCURRENT);
    }
    else if (sDataType.compare("eddyPhase") == 0){
        if (nlhs != 5) { mexErrMsgTxt("Expected output arguments: [RXSamples, RXTime, TXTime, TrigTime, ECCPhase].\n"); }
        dsp.setDataType(SEQSIM::DataType::EDDYPHASE);
    }
    else{
        mexErrMsgTxt("Supported data types are: 'gradient', 'kspace', 'slewRate', 'eddyCurrent' and 'eddyPhase'.\n");
    }

    if (sDataType.compare("eddyCurrent") == 0 || sDataType.compare("eddyPhase") == 0){
        if (nrhs != 6){ mexErrMsgTxt("Expected input arguments: [FileName, DataType, OutputMode CoeffsX, CoeffsY, CoeffsZ].\n"); }
    }
    
    //---------------------------------------------------------------------
    // Get coefficients (if needed)
    //---------------------------------------------------------------------   
    if (nrhs==6){

        const mxArray *mxCoeffX = prhs[3];
        const mxArray *mxCoeffY = prhs[4];
        const mxArray *mxCoeffZ = prhs[5];

        SEQSIM::ECC_Coeff sCoeffX;
        SEQSIM::ECC_Coeff sCoeffY;
        SEQSIM::ECC_Coeff sCoeffZ;

        setB0CorrCoeff(mxCoeffX, sCoeffX);
        setB0CorrCoeff(mxCoeffY, sCoeffY);
        setB0CorrCoeff(mxCoeffZ, sCoeffZ);
        
        // Set coefficients
        dsp.setB0CorrCoeff(sCoeffX, sCoeffY, sCoeffZ);
    }
        
	//---------------------------------------------------------------------
	// Configure
	//---------------------------------------------------------------------
	// Set verbose mode (see enum Verbose in Types.h)
	dsp.setVerboseMode(SEQSIM::DISPLAY_BASIC);

    
    //---------------------------------------------------------------------
	// Run
	//---------------------------------------------------------------------
    dsp.run(plhs);

}





void setB0CorrCoeff(const mxArray *mxCoeff, SEQSIM::ECC_Coeff &sCoeff) {

	long NCoefficentsAmp, NCoefficentsTau;
	if (!mxIsStruct(mxCoeff))
		mexErrMsgTxt("Input must be a structure.");

	// get input arguments 
	int        nfields;
	mwSize     NStructElems;

	nfields = mxGetNumberOfFields(mxCoeff);
	NStructElems = mxGetNumberOfElements(mxCoeff);

	if (NStructElems != 1) {
		mexErrMsgTxt( "Coefficient structure must contain only amplitudes 'Amp' and decay constants 'tau'.");
	}
	if (nfields != 2) {
		mexErrMsgTxt( "Coefficient structure must contain only amplitudes 'Amp' and decay constants 'tau'.");
	}

	mxArray *mx = NULL;
	// Amplitudes
	if ((mx = mxGetField(mxCoeff, 0, "Amp"))) {

		if (!mxIsNumeric(mx)) {
			mexErrMsgTxt( "All coefficients must be numeric.");
		}
		if (!mxIsDouble) {
			mexErrMsgTxt( "All coefficients must be of double precision.");
		}

		double *temp = mxGetPr(mx);
		NCoefficentsAmp = mxGetNumberOfElements(mx);
		for (long i = 0; i < NCoefficentsAmp; i++) {
			sCoeff.vfAmp.push_back((double)temp[i]);
		}

	}
	else {
		mexErrMsgTxt( "Could not find 'Amp' in coefficient structure.");
	}

	// Decay constants
	if ((mx = mxGetField(mxCoeff, 0, "Tau"))) {

		if (!mxIsNumeric(mx)) {
			mexErrMsgTxt( "All coefficients must be numeric.");
		}
		if (!mxIsDouble) {
			mexErrMsgTxt( "All coefficients must be of double precision.");
		}

		double *temp = mxGetPr(mx);
		NCoefficentsTau = mxGetNumberOfElements(mx);
		for (long i = 0; i < NCoefficentsTau; i++) {
			sCoeff.vfTau.push_back((double)temp[i]);
		}
	}
	else {
		mexErrMsgTxt( "Could not find 'tau' in coefficient structure.");
	}

	if (NCoefficentsAmp != NCoefficentsTau) {
		mexErrMsgTxt( "Number of amplitudes and decay constants must be the same.");
	}

	// Print coefficients
	mexPrintf("Tau: ");
	for (long i = 0; i < NCoefficentsTau; i++) {
		mexPrintf("\t %f", sCoeff.vfTau.at(i));
	}
	mexPrintf("\nAmp: ");
	for (long i = 0; i < NCoefficentsAmp; i++) {
		mexPrintf("\t %f", sCoeff.vfAmp.at(i));
	}
	mexPrintf("\n");

}
